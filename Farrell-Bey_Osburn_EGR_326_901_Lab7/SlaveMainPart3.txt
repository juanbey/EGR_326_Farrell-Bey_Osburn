
// SLAVE

#include "msp.h"
#include <stdio.h>
#include <stdbool.h>
#include "motor.h"
#include "timers.h"

#define SLAVE_ADDRESS 0x48

char RXData;
uint32_t stepsToHome = 0;

void main(void)
{
    WDT_A->CTL = WDT_A_CTL_PW | WDT_A_CTL_HOLD;
    SysTick_Init();
	Motor_Pin_Init();

    //Slave init
    P6->SEL0 |= BIT4 | BIT5;                // P1.6 and P1.7 as UCB0SDA and UCB0SCL
    
    EUSCI_B1->CTLW0 |= EUSCI_B_CTLW0_SWRST; // Hold EUSCI_B1 module in reset state
    EUSCI_B1->CTLW0 |= EUSCI_B_CTLW0_MODE_3 | EUSCI_B_CTLW0_SYNC;
    EUSCI_B1->I2COA0 = SLAVE_ADDRESS | EUSCI_B_I2COA0_OAEN;
    EUSCI_B1->CTLW0 &= ~EUSCI_B_CTLW0_SWRST;  // Clear SWRST to resume operation
    EUSCI_B1->IFG &= ~EUSCI_B_IFG_RXIFG0;     // Clear EUSCI_B1 RX interrupt flag
    EUSCI_B1->IE |= EUSCI_B_IE_RXIE0;         // Enable EUSCI_B1 RX interrupt
    NVIC->ISER[0] = 1 << ((EUSCIB1_IRQn) & 31); // EUSCI_B1 interrupt is enabled in NVIC
    __enable_irq();                           // All interrupts are enabled

    //main
    SCB->SCR |= SCB_SCR_SLEEPONEXIT_Msk;      // Sleep on exit
    __sleep();                                // enter LPM0
}

void EUSCIB1_IRQHandler(void)
{
    uint32_t status = EUSCI_B1->IFG; // Get EUSCI_B1 interrupt flag
    EUSCI_B1->IFG &= ~EUSCI_B_IFG_RXIFG0;

    if (status & EUSCI_B_IFG_RXIFG0)
    { // Check if receive interrupt occurs
        RXData = EUSCI_B1->RXBUF; // Load current RXData value to transmit buffer

        if (RXData == 'H')  //Reset home 
        {
            DegreesToStep(stepsToHome, 0);
            stepsToHome = 0;
        }

        else if(RXData == 11 + '0'){
            ;   //Do nothing input was 0
        }

        else
        {
            stepsToHome += RXData - '0';
            DegreesToStep((RXData - '0'), 1); 
        }
    } 
}
