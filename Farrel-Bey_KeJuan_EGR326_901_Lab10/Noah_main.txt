#include "msp.h"
#include "stdio.h"
#include "ST7735.h"

void Clock_Init48MHz(void);
void timerInit(void);

int time = 1;

char number;

void main(void)
{
    __disable_interrupts(); // Disable all interrupts

    WDT_A->CTL = WDT_A_CTL_PW | WDT_A_CTL_HOLD; // stop watchdog timer

    Clock_Init48MHz();
    ST7735_InitB();
    ST7735_InitR(INITR_GREENTAB);
    Output_Clear();
    ST7735_FillScreen(0x0000);

    P6->DIR &= ~BIT7;
    P6->REN |= BIT7;
    P6->OUT |= BIT7;
    P6->IE |= BIT7;
    P6->IES |= BIT7;
    P5->DIR |= BIT2;
    P5->OUT |= BIT2;

    Delay1ms(500);
    P5->OUT = 0x0000;

    timerInit();
    NVIC_EnableIRQ(PORT6_IRQn); // Enable button interrupts
    NVIC_EnableIRQ(TA0_N_IRQn); // Interrupt for TA0 enabled
    __enable_interrupts(); // Enable all interrupts

    WDT_A->CTL = 0x5A00 | 1 << 5 | 0 << 4 | 1 << 3 | 4;

    while (1)
    {

        number = time + '0';

        ST7735_DrawChar(51, 64, number, 0xFFFF, 0x0000, 4); // draws the number in the center
        // Delay1ms(500); //Delay1mss half a second
    }
}

void Clock_Init48MHz(void)
{
    // Configure Flash wait-state to 1 for both banks 0 & 1
    FLCTL->BANK0_RDCTL = (FLCTL->BANK0_RDCTL & ~(FLCTL_BANK0_RDCTL_WAIT_MASK)) |
                         FLCTL_BANK0_RDCTL_WAIT_1;
    FLCTL->BANK1_RDCTL = (FLCTL->BANK0_RDCTL & ~(FLCTL_BANK0_RDCTL_WAIT_MASK)) |
                         FLCTL_BANK1_RDCTL_WAIT_1;

    // Configure HFXT to use 48MHz crystal, source to MCLK & HSMCLK*
    PJ->SEL0 |= BIT2 | BIT3; // Configure PJ.2/3 for HFXT function
    PJ->SEL1 &= ~(BIT2 | BIT3);
    CS->KEY = CS_KEY_VAL; // Unlock CS module for register access
    CS->CTL2 |= CS_CTL2_HFXT_EN | CS_CTL2_HFXTFREQ_6 | CS_CTL2_HFXTDRIVE;
    while (CS->IFG & CS_IFG_HFXTIFG)
        CS->CLRIFG |= CS_CLRIFG_CLR_HFXTIFG;
    /* Select MCLK & HSMCLK = HFXT, no divider */
    CS->CTL1 = CS->CTL1 & ~(CS_CTL1_SELM_MASK |
                            CS_CTL1_DIVM_MASK |
                            CS_CTL1_SELS_MASK |
                            CS_CTL1_DIVHS_MASK) |
               CS_CTL1_SELM__HFXTCLK |
               CS_CTL1_SELS__HFXTCLK |
               0x02000000 |
               CS_CTL1_DIVS_0;

    // CS->CTL1 = CS->CTL1 | CS_CTL1_DIVS_0;    // change the SMCLK clock speed to 12 MHz.
    CS->KEY = 0; // Lock CS module from unintended accesses
}

void timerInit(void)
{
    TIMER_A0->CTL = 0b0000000111010100; // ACLK, Divide by 8, Count Up, Clear to start
    TIMER_A0->CCR[0] = 1024;
    TIMER_A0->CCR[1] = 1024; // Count to 1 second

    // TIMER_A0->EX0 = 0b0000000000000111;           //divider of 8
    TIMER_A0->CCTL[1] = 0b0000000011110100; // CCR1 reset/set mode 7, with interrupt.
    TIMER_A0->CCTL[1] &= ~BIT0; // Clear Timer A0.1 interrupt flag
    TIMER_A0->CCTL[1] &= ~BIT1; // Clear Timer A0.1 overflow flag

    number = 0 + '0';

    ST7735_DrawChar(51, 64, number, 0xFFFF, 0x0000, 4); // draws the number in the center
}

void TA0_N_IRQHandler()
{
    TIMER_A0->CCTL[1] &= ~BIT0; // Clear Timer A0.4 interrupt flag
    TIMER_A0->CCTL[1] &= ~BIT1; // Clear Timer A0.4 overflow flag
    time = time + 1;
    TIMER_A0->CCTL[1] &= ~(BIT0 | BIT1); // Clear interrupt flag
}

void PORT6_IRQHandler()
{
    if (!(P6->IN & BIT7))
    { // P3.2
        Delay1ms(30); // Wait 30000 cycles for debounce
        if (!(P6->IN & BIT7))
        {
            time = 0;
            WDT_A->CTL = 0x5A00 | 1 << 5 | 0 << 4 | 1 << 3 | 4;
        }
    }
    P6->IFG &= ~BIT7; // Clear Interrupt Flag
}