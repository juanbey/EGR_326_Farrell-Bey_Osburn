/**************************************************************************************
* Title: Farrell-Bey_KeJuan_EGR_326_901_Lab4
* Filename: maincm
* Author: KeJuan Farrell-Bey & Jonathan Osburn
* Course: EGR 326-901
* Date: 9/22/2022
* Assignment: Lab # 4: I/O Interfacing with the MSP432
* Instructor: Dr. Brian Krug
*
* Description
*
* Revision: Initial draft
***************************************************************************************/
#include "msp.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Pin macros

#define SW BIT0     // P5.0
#define DT BIT1     // P5.1
#define CLK BIT2    // P5.2
#define RED BIT6    // P5.6
#define BLUE BIT7    // P5.7

#define ROWS BIT0 | BIT1 | BIT2 | BIT3  //P4.0 - 4.3
#define COLS BIT4 | BIT5 | BIT6         //P4.4 - 4.6

#define PERIOD 9398        // Trigger Period

// Jay's Pin macros
// #define SW BIT0     // P4.0
// #define DT BIT1     // P4.1
// #define CLK BIT5    // P4.5
// #define RED BIT3    // P4.3

void Decade_Init(void);         // prototype for GPIO initialization
void SysTick_Init(void);
void LED_init(void);
void SysTick_delay (uint16_t delay);
void keypad_init(void);         // prototype for GPIO initialization
uint8_t Read_Keypad(void);      // prototype for keypad scan subroutine
void GetPin(int input, int pin[2]);


volatile uint32_t cw, ccw = 0;      //Clockwise and counter clockwise counters
uint8_t num, key;       //value of key pressed and key press detection variable
volatile int32_t count, userVal, digits, turnRatio = 0;     //values of decade encoder count and user entered value
volatile bool reset = true;     //Reset flag
int pin[2];     //array to hold number entry
volatile bool enteredNum = false;   //flag for valid number entery 



void main(void)
{
    WDT_A->CTL = WDT_A_CTL_PW | WDT_A_CTL_HOLD;     // stop watchdog timer


    //Initialize functions
    Decade_Init();
    LED_init();
    keypad_init();
    SysTick_Init ();

    userVal = -4000;    //set user value to impossible value for default

    while(1){
      if(reset){    //if the reset flag is raised
            P5->OUT &= ~(RED | BLUE);   //turn off leds
           userVal = -4000;     //reset user value
           enteredNum = false;  //lower valid entry flag
           //reset coounter flags
           count = 0;   
           cw = 0;
           ccw = 0;
           printf("Enter a number from 1 - 99 for the encoder to illuminate an LED.\n");
           while(!enteredNum){  //while no valid number entered
                key = Read_Keypad();    //read the keypad

                if(key == 1){       //if a key press is detected
                    GetPin(num, pin);   //get the number pressed
                }
                SysTick_delay(10);
           }
       reset = false;   //lower reset flag 
      }

       if((turnRatio == userVal) && (cw > ccw)){        //if the number of pulses equal the user number and clockwise it greater
           P5->OUT |= RED;      //Turn red on
       }
       else if((turnRatio > userVal) && (cw > ccw) || (turnRatio < userVal) && (cw > ccw)){ //If lower or higher turn it off
           P5->OUT &= ~RED;      //Turn red off
       }
       else{
           ;
       }

       if((turnRatio == userVal) && (ccw > cw)){    //if the pulse number equals the user number and counter clockwise
           P5->OUT |= BLUE;      //Turn blue on 
       }
       else if((turnRatio > userVal) && (ccw > cw) || (turnRatio < userVal) && (ccw > cw)){
           P5->OUT &= ~BLUE;      //Turn blue off
       }
       else{
           ;
       }

    }
}





/********************************************************************
Interrupt Serivce Ruoutine for port 2 that sets the tryDebounce flag(s)
*********************************************************************/
void PORT5_IRQHandler(void){
    if(P5->IFG & CLK){                  // if CLk interrupt occurs
        if((P5->IN & CLK) == (P5->IN & DT)){    //If inputs are equal
                count--;
                ccw++;
        }
        else{                                   //If inputs are not equal
                count++;
                cw++;
        }

        P5->IES ^= (CLK | DT);      // Set pin interrupt trigger low to high
    }

    else if(P5->IFG & DT){                  // if DT interrupt occurs
        if((P5->IN & CLK) == (P5->IN & DT)){    //If inputs are equal
                count++;
                cw++;
        }
        else{                                   //If inputs are not equal
                count--;
                ccw++;
        }

        P5->IES ^= (DT | CLK);      // Set pin interrupt trigger low to high
    }

    else{
        ;
    }


    if (P5->IFG & SW){      //If push button raise reset flag
        reset = true;
    }

    turnRatio = abs(cw - ccw);
    P5->IFG = 0;       //clear flag
}

/********************************************************************
This function initalizes pins 6 & 7 on port 2 as input GPIO to recieve
input from a button switch.
*********************************************************************/
void Decade_Init(void){
    P5->SEL0 &= ~(DT | CLK | SW);
    P5->SEL1 &= ~(DT | CLK | SW);   //configure P2.6 and P2.7 as GPIO
    P5->DIR &= ~(DT | CLK | SW);    //make P2.6 and P2.7 input
    P5->REN |= (DT | CLK | SW);     //enable pull resistors
    P5->OUT |= (DT | CLK | SW);     //Pins are pull-up


    P5->IES |= (DT | CLK | SW);     //Set pin interrupt trigger from high to low
    P5->IFG = 0;
    P5->IE |= (DT | CLK | SW);       //Set interrupts

    NVIC_EnableIRQ(PORT5_IRQn); //Enable interrupts on port 1
    __enable_interrupts();
}
/********************************************************************
This function sets up 3 pins to work with TimerA
*********************************************************************/
void LED_init(void){
    P5->SEL0 &= ~(RED | BLUE);
    P5->SEL1 &= ~(RED | BLUE);     //configure P5.6 for TimerA2.2
    P5->DIR |= (RED | BLUE);       //make P5.6 an output
    P5->REN &= ~(RED | BLUE);     //enable pull down resistors
    P5->OUT &= ~(RED | BLUE);      //Off
}

void SysTick_Init (void){        //initialization of systic timer
    SysTick -> CTRL  = 0;                      // disable SysTick During step
    SysTick -> LOAD = 0x00FFFFFF;             // max reload value
    SysTick -> VAL     = 0;                  // any write to current clears it
    SysTick -> CTRL  = 0x00000005;          // enable systic, 3MHz, No Interrupts
  }


void SysTick_delay (uint16_t delay){          // Systick delay function
    SysTick -> LOAD = ((delay * 3000) - 1);               //delay for 1 msecond per delay value
    SysTick -> VAL     = 0;                              // any write to CVR clears it
    while ( (SysTick -> CTRL  &  0x00010000) == 0);    // wait for flag to be SET
}


void keypad_init(void){
    P4->SEL0 &= ~(ROWS | COLS);
    P4->SEL1 &= ~(ROWS | COLS);                         //configure P4.0, P4.1, P4.2, P4.3, P4.4, P4.5, P4.6  as GPIO
    P4->DIR &= ~(ROWS | COLS);                          //make P4.0, P4.1, P4.2, P4.3, P4.4, P4.5, P4.6 input
    P4->REN |= (ROWS);     //enable pull resistors on rows
    P4->OUT |= (ROWS);     // Rows are pull-up
}


uint8_t Read_Keypad(void){
    uint8_t col, row;

    for ( col = 0; col < 3; col++ ){
        P4->DIR = 0x00;                 // Set Columns to inputs
        P4->DIR |= BIT(4 + col);        // Set column 3 to output
        P4->OUT &= ~BIT(4 + col);      // Set column 3 to LOW

        SysTick_delay(10);           // Delay the while loop
        row = P4->IN & 0x0F;                  // read all rows

        while (!(P4IN & BIT0) | !(P4IN & BIT1) | !( P4IN & BIT2) | !( P4IN & BIT3));

        if (row != 0x0F){
            break;                  // if one of the input is low, some key is reset.
        }
    }

    P4->DIR = 0x00;                             // Set Columns to inputs

    if (col == 3){
        return 0;
    }


    if (row == 0x0E){
        num = col + 1;        // key in row 0
    }

    if (row == 0x0D){
        num = 3 + col + 1;       // key in row 1
    }

    if (row == 0x0B){
        num = 6 + col + 1;       // key in row 2
    }

    if (row == 0x07){
        num = 9 + col + 1;       // key in row 3
    }

    return 1;
}


void GetPin(int input, int pin[2]) {
   int temp;                 //Temporary vars for shifting

   if (input != 10 && input != 12) {
       if(input == 11){
           input = 0;
       }
         temp = pin[0];       //Shift each digit in the pin over and fill in the next user input

         pin[1] = temp;
         pin[0] = input;
         digits++;
        printf("Entered: %d\n", input);   //If there are no invalid values, print eneterd value
   }

   else{
        printf("Please select an integer from the keypad\n");
        if(input == 10){
            printf("Entered: *\n");   //If there are no invalid values, print eneterd value
        }
        if(input == 12){
            printf("Entered: #\n");   //If there are no invalid values, print eneterd value
        }
        digits = 0;
        pin[0] = 25;
        pin[1] = 25;
   }


    if (digits == 2) {
        printf("You entered:  %d %d\n", pin[1], pin[0]);   //If there are no invalid values, print
        digits = 0;
        userVal = (pin[1] * 10) + pin[0];
        enteredNum = true;
    }
}


